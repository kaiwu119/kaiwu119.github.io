{"meta":{"title":"KaiWu'Blog","subtitle":"热爱生活，记录与分享","description":null,"author":"KaiWu","url":"https://kaiwu119.github.io","root":"/"},"pages":[{"title":"","date":"2019-08-25T08:06:12.902Z","updated":"2019-08-25T08:06:12.736Z","comments":true,"path":"google8b6e4013398f3653.html","permalink":"https://kaiwu119.github.io/google8b6e4013398f3653.html","excerpt":"","text":"google-site-verification: google8b6e4013398f3653.html"},{"title":"about","date":"2019-08-24T05:05:38.000Z","updated":"2019-08-24T05:14:50.105Z","comments":true,"path":"about/index.html","permalink":"https://kaiwu119.github.io/about/index.html","excerpt":"","text":"关于我大学本科：西北农林科技大学专业：软件工程从事：计算机图形学 研究生就读于中国科学院深圳先进技术研究院，刚开始研一生涯，偶然有机会接触hexo，便想着自己搭建一个自己的博客，记录自己的学习和生活。之前有在CSDN上写博客，但是之后主要更新本博客。"},{"title":"categories","date":"2019-08-23T13:28:32.000Z","updated":"2019-08-23T13:29:13.956Z","comments":true,"path":"categories/index.html","permalink":"https://kaiwu119.github.io/categories/index.html","excerpt":"","text":""},{"title":"friendLinks","date":"2019-08-24T05:17:16.000Z","updated":"2019-08-24T05:17:16.494Z","comments":true,"path":"friendLinks/index.html","permalink":"https://kaiwu119.github.io/friendLinks/index.html","excerpt":"","text":""},{"title":"photoAlbum","date":"2019-08-24T05:33:56.000Z","updated":"2019-08-24T05:33:56.597Z","comments":true,"path":"photoAlbum/index.html","permalink":"https://kaiwu119.github.io/photoAlbum/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-08-23T13:05:28.000Z","updated":"2019-08-23T13:29:26.723Z","comments":true,"path":"tags/index.html","permalink":"https://kaiwu119.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Majority Element (divide and conquer)","slug":"Majority-Element-divide-and-conquer","date":"2019-10-12T14:03:06.000Z","updated":"2019-10-12T14:32:55.810Z","comments":true,"path":"2019/10/12/Majority-Element-divide-and-conquer/","link":"","permalink":"https://kaiwu119.github.io/2019/10/12/Majority-Element-divide-and-conquer/","excerpt":"","text":"Majority Element (Divide and Conquer)you can find this problem in LeetCode-169 Problem description Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times. You may assume that the array is non-empty and the majority element always exist in the array. The range of length of array is n(1≤n≤5,000,000) and the element (integer) in array is no bigger than 10,000,00000. 这题的主要意思是从一个n个元素的数组中找到数目大于n/2的元素， 如输入n=7和数组 72 1 2 2 3 3 2 则输出 2 主要思路这里主要采用了一个策略，因为从题目中可以得知，一定存在一个元素是majority Element，所以我们可以每次消去两个不同的数字，那么最后保留的一定是majority Element。 具体方法每次将数组分成两个部分a和b，如果这两个部分中的保留的元素分别为Ea和Eb如果Ea和Eb相等那么返回Ea，如果Ea和Eb不相等则返回error（error表示消去这两个元素，这里我们可以用最大值表示error=10,000,00000），所以最后返回的一定是majority Element 代码（C++）1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;int error=1000000000;int getMajorityElement(int *a,int b,int e)&#123; int mid =(b+e)/2; if(b&gt;=e) return a[b];```int n1= getMajorityElement(a,b,mid);int n2= getMajorityElement(a,mid+1,e);if(n1 == error &amp;&amp; n2 == error) return error;if(n1 == error) return n2;if(n2 == error) return n1;if(n1 == n2) return n1;else return error;```&#125;int main()&#123; int n; scanf(\"%d\",&amp;n); int *a = new int [n]; for( int i =0; i&lt; n; i++) scanf(\"%d\",&amp;a[i]); int num = getMajorityElement(a,0,n-1); printf(\"%d\\n\",num);```return 0;```&#125; 时间复杂度分析该算法的时间复杂度为O(n​) 分析递归函数 getMajorityElement所用时间规律： (hexo不能渲染latex公式…，我也懒得配置了，就直接截图了) 所以该函数最终的时间复杂度为O(n)","categories":[{"name":"算法","slug":"算法","permalink":"https://kaiwu119.github.io/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://kaiwu119.github.io/tags/算法/"},{"name":"分治","slug":"分治","permalink":"https://kaiwu119.github.io/tags/分治/"}]},{"title":"PCA实例和python实现","slug":"PCA实例和python实现","date":"2019-10-12T13:04:46.000Z","updated":"2019-10-12T13:26:56.236Z","comments":true,"path":"2019/10/12/PCA实例和python实现/","link":"","permalink":"https://kaiwu119.github.io/2019/10/12/PCA实例和python实现/","excerpt":"","text":"本文给出一个PCA的具体实例和源码： PCA算法算法步骤： 设有m条n维数据。 1）将原始数据按列组成n行m列矩阵X 2）将X的每一行（代表一个属性字段）进行零均值化，即减去这一行的均值 3）求出协方差矩阵C=1/m*XXT 4）求出协方差矩阵的特征值及对应的特征向量 5）将特征向量按对应特征值大小从上到下按行排列成矩阵，取前k行组成矩阵P 6）Y=PX即为降维到k维后的数据 python实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import numpy as npimport mathfrom matplotlib import pyplot as pltdef setK(featureValue, rate): eigValInd = np.argsort(-featureValue) #返回特征值由大到小排序的下标值 for i in range(1, featureValue.size+1): topK = eigValInd[i-1] Val = featureValue[topK] a = Val.sum() b = featureValue.sum() if a/b &gt;= rate: break return i#dataMat 为原始的输入样本矩阵，每一行为一个样本，k为保留的主成分个数,rate是保留的主成分占原有的百分比def PCA(dataMat,k=0, rate=0.5): # 按列求均值, average = np.mean(dataMat, axis=0) print(\"means\\n\",average) m, n = np.shape(dataMat) # 减去均值 meanRemoved = dataMat - np.tile(average, (m,1)) print(\"meanRemoved\\n\", meanRemoved) # 标准差归一化 normData = meanRemoved / np.std(dataMat) print(\"normal_data\\n\",normData) # 求协方差矩阵 covMat = np.cov(meanRemoved.T) # 求协方差矩阵的特征值和特征向量 featureValue, featureVec = np.linalg.eig(covMat) print(\"featureValue\\n\",featureValue) print(\"featureVec\\n\", featureVec) # 返回特征值由大到小排序的下标 featureValInd = np.argsort(-featureValue) #按照特征值大小选择前K个数据 if k==0: princpleNum = setK(featureValue, rate) else: princpleNum = k # [:princpleNum]表示前princpleNum行，因此之前需要转置处理（选择前princpleNum个大的特征值） selectVec = np.matrix(featureVec.T[:princpleNum]) pcaData = meanRemoved * selectVec.T return pcaData#从文件中读取样本矩阵filePath = \"./mat.txt\"dataMat = np.loadtxt(filePath,delimiter=' ')dataMat = np.mat(dataMat)pcaData = PCA(dataMat,1)print(\"pcaData\\n\",pcaData) 测试数据输入样本矩阵： 1 11 32 34 42 4 输出： 计算每一维的均值 [ 2. 3.] 每一个样本减去对应维度均值 [-1. -2.] [-1. 0.] [ 0. 0.] [ 2. 1.] [ 0. 1.] 计算协方差的特征值 [ 2.5 0.5] 计算协方差的特征向量 [ 0.70710678 -0.70710678] [ 0.70710678 0.70710678] 因为只保留一个维度，所以最后经过PCA处理的数据结果为 [-2.12132034] [-0.70710678] [ 0. ] [ 2.12132034] [ 0.70710678] 参考资料： PCA的数学原理","categories":[{"name":"模式识别","slug":"模式识别","permalink":"https://kaiwu119.github.io/categories/模式识别/"}],"tags":[{"name":"模式识别","slug":"模式识别","permalink":"https://kaiwu119.github.io/tags/模式识别/"},{"name":"数据降维","slug":"数据降维","permalink":"https://kaiwu119.github.io/tags/数据降维/"}]},{"title":"三维树木建模方法","slug":"三维树木建模方法","date":"2019-08-24T07:45:45.000Z","updated":"2019-08-24T10:28:56.469Z","comments":true,"path":"2019/08/24/三维树木建模方法/","link":"","permalink":"https://kaiwu119.github.io/2019/08/24/三维树木建模方法/","excerpt":"","text":"这是我csdn上的一个博文 几种建模方法概述在游戏设计、电影和城市规划领域，3D树的建模在虚拟场景中占了很重要的角色。因此如何快速建立真实的三维树木模型一直是研究的热点问题。 关于树木建模存在很多经典的方法，典型的方法是利用L-system建模，使用参数化方法操作复杂的参数,这个方法擅长描述植物特性不同的物种，但是这种方法需要一定的专业知识而且只能控制局部特征，并不能控制整体的特征。另一方面，L系统与环境缺少交互作用，因为植物的生长是一件比较复杂的问题，需要环境的控制才能模拟出更为真实的植物模型。这就促使了开放式L系统的产生。开放式L系统：是对L系统扩展，以支持更丰富的环境相互作用。考虑的植物与环境的相互作用主要包含空间竞争、根系对营养和水分的竞争以及对阳光的竞争等。 当需要真实感还原现实世界中的树木时, 应用L系统的方法就不太适用. 因为对这些树木模型的参数及其对应的模型空间存在着一定的局限性。这时主要采用的方法是基于视频图像和点云的重建，将视频图像和点云的重建放在一起是因为，基于视频图像的方法其实就是根据图像序列先还原成一个树木的点云，然后再根据点云进行重建，而基于点云的重建则是直接根据设备获取了真实场景的点云数据。 基于视频图像或三维点云的方法主要局限于重建现实世界中的树木, 而基于草图的方法则允许用户在建模时能同时拥有较大的自由度以及创造力. 除此之外, 草图能让用户以一种比较直观的方式来表达其建模意图, 这正是前面所述的建模方式所欠缺的。 下面给出我尝试过的获得树木的骨架的几种方法：图一为分形树（使用L-system），图二为基于草图建树，图三为基于点云生成树。 图一 图二 图三 虽然有那么多种建树的方法，其实每个方法的核心都是提取树的骨架得到树的骨架的方法很多而且每种方法都不太相同，所以这里主要介绍通用的3D树的建模方法，对每种提取骨架的方法不进行细致讨论。 枝干表示对于一棵树，枝干是其主要的组成部分，我们在计算机中表示一棵树的枝干是有很多方式的。 最为简单的方法：我们用一个圆柱或者一个多棱柱来模拟一节枝干，我们让这些圆柱紧密的连接就能产生一个光滑的枝条，这就是现在植物建模普遍使用的方法。使用圆柱代替枝干也方便了帮树木模型贴上树皮。为了增加植物模型的视觉真实感，我们需要对枝干的宽度进行调整。自然界中枝干和其子枝干是不一样粗的，所以我们要知道枝干和子枝干半径的对应关系。对应关系如下:其中a是一个系数，ri是子分支的半径，r是父分支的半径。 生成子枝干果一种方法只能提取树的主枝干的骨架，如草图建树。那么我们要人工的给这个骨架生成多个分支骨架，从而才能得到整棵树的骨架。主要使用的方法是：利用植物的自相似性进行子枝干的生成，如下图： 这里定义枝干η = {Sγ; γ = 1, 2, .. . , k} 我们在η中选择一个点Sm，把从S1到Sm作为一个子枝干，通过旋转平移添加到η中，从而实现了分支的拓展。 树叶建模 为了提升一棵树的真实感，合理的树叶是必然的。我们平时观察的树叶都是一个复杂的曲面，但是如果我们直接去对树叶建立一 个曲面（树的叶子可是繁多的），渲染如此多的树叶必然很影响效率的，而且叶子很小，效果也不见得有好，这性价比显然是很低的。 所以我们常用的方法是使用一种带alpha值的纹理图表示树叶。","categories":[{"name":"图形学","slug":"图形学","permalink":"https://kaiwu119.github.io/categories/图形学/"}],"tags":[{"name":"图形学","slug":"图形学","permalink":"https://kaiwu119.github.io/tags/图形学/"},{"name":"建模","slug":"建模","permalink":"https://kaiwu119.github.io/tags/建模/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-08-24T06:35:26.469Z","updated":"2019-08-23T14:20:56.424Z","comments":true,"path":"2019/08/24/hello-world/","link":"","permalink":"https://kaiwu119.github.io/2019/08/24/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"Test2","slug":"Test2","permalink":"https://kaiwu119.github.io/categories/Test2/"}],"tags":[{"name":"Testing","slug":"Testing","permalink":"https://kaiwu119.github.io/tags/Testing/"},{"name":"default","slug":"default","permalink":"https://kaiwu119.github.io/tags/default/"}]}]}